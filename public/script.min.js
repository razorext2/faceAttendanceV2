
let videoStream = null,
  webcamStarted = !1,
  modelsLoaded = !1,
  detectionInterval = null;

const labels = [],
  detectedFaces = new Set,
  video = document.getElementById("video"),
  overlay = document.getElementById("overlay"),
  startButton = document.getElementById("startButton"),
  endButton = document.getElementById("endAttendance"),
  csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute("content"),
  canvInfo = document.getElementById("canvAttend"),
  pegawaiKosong = document.getElementById("pegawaiKosong"),
  pegawaiInfo = document.getElementById("pegawaiInfo"),
  lokasi = "Titi Kuning",
  originalConsoleLog = console.log;

fetch("/api/getPegawai").then((e => e.json())).then((e => {
  console.log("Initializing application"), labels.push(...e), initializeFaceAPI()
})).catch((e => console.error("Error fetching data", e)));

function initializeFaceAPI() {
  Promise.all([faceapi.nets.ssdMobilenetv1.loadFromUri("/models"), faceapi.nets.faceRecognitionNet.loadFromUri(
    "/models"), faceapi.nets.faceLandmark68Net.loadFromUri("/models")]).then((() => {
      modelsLoaded = !0, console.log("Models loaded successfully")
    }))
}

async function getImagePathsForLabel(e) {
  try {
    const t = await fetch(`/api/pegawai-images/${encodeURIComponent(e)}`);
    if (!t.ok) throw new Error("Network response was not ok");
    return await t.json()
  } catch (e) {
    return console.log("Some folder of employee is empty. "), console.log("Please register their face first."), []
  }
}

async function getLabeledFaceDescriptions() {
  const e = [];
  for (const t of labels) {
    const n = [],
      a = await getImagePathsForLabel(t);
    for (const e of a) try {
      const t = await faceapi.fetchImage(e),
        a = await faceapi.detectSingleFace(t).withFaceLandmarks().withFaceDescriptor();
      console.log("Fetching image paths..."), a && n.push(a.descriptor)
    } catch (t) {
      console.error(`Error processing ${e}:`, t)
    }
    n.length > 0 && e.push(new faceapi.LabeledFaceDescriptors(t, n))
  }
  return e
}

async function startFaceDetection() {
  if (!detectionInterval) try {
    const e = await getLabeledFaceDescriptions();
    if (console.log("Processing image for face data..."), 0 === e.length) return void console.error(
      "No labeled face descriptors found.");
    const t = new faceapi.FaceMatcher(e),
      n = {
        width: video.width,
        height: video.height
      };
    faceapi.matchDimensions(overlay, n);
    const a = overlay.getContext("2d", {
      willReadFrequently: !0
    });
    if (!a) return void console.error("Failed to get canvas context.");
    detectionInterval = setInterval((async () => {
      try {
        const e = await faceapi.detectAllFaces(video).withFaceLandmarks().withFaceDescriptors(),
          o = faceapi.resizeResults(e, n),
          s = document.createElement("canvas");
        s.width = overlay.width, s.height = overlay.height;
        let i = !1,
          r = null,
          c = null,
          l = null;
        for (const e of o) {
          const n = t.findBestMatch(e.descriptor),
            a = n.distance;
          if ("unknown" !== n.label && a < .4 && !detectedFaces.has(n.label)) {
            const t = e.detection.box;
            new faceapi.draw.DrawBox(t, {
              label: n.toString()
            }).draw(s), i = !0, r = n.label, detectedFaces.add(n.label);
            const a = await getPegawaiDataByLabel(r);
            a && (displayPegawaiData(a), c = a.kode_pegawai, l = a.nik_pegawai)
          }
        }
        if (i && c) {
          const e = await captureImage();
          if (e) {
            const t = await getPegawaiDataByLabel(r);
            await saveImageToServer(e, r), await saveAttendance(c, l, t), canvInfo.style.display = "block"
          } else console.error("Failed to capture image")
        }
        a.clearRect(0, 0, overlay.width, overlay.height), a.drawImage(s, 0, 0)
      } catch (e) {
        console.error("Error during face detection or matching:", e)
      }
    }), 500), console.log("Face detection started")
  } catch (e) {
    console.error("Error initializing face recognition:", e)
  }
}

function stopFaceDetection() {
  detectionInterval && (clearInterval(detectionInterval), detectionInterval = null, console.log(
    "Face detection stopped"))
}

function stopWebcam() {
  videoStream && (console.log("Stopping webcam..."), stopFaceDetection(), videoStream.getTracks().forEach((e => e
    .stop())), video.srcObject = null, videoStream = null, webcamStarted = !1)
}

function captureImage() {
  const e = document.createElement("canvas");
  e.width = video.videoWidth, e.height = video.videoHeight;
  return e.getContext("2d").drawImage(video, 0, 0, e.width, e.height), new Promise((t => {
    e.toBlob((e => {
      t(e || null)
    }), "image/png"), console.log("Image captured...")
  }))
}

async function saveImageToServer(e, t) {
  const n = new FormData;
  n.append("image", e, "capturedImg.png"), n.append("label", t);
  try {
    const e = await fetch("/api/saveImage", {
      method: "POST",
      headers: {
        "X-CSRF-TOKEN": csrfToken
      },
      body: n
    });
    if (e.ok) {
      const t = await e.json();
      t.imageUrl && (displayImageOnCanvas(t.imageUrl), console.log("Image saved and displayed on canvas"))
    } else console.error("Failed to save image")
  } catch (e) {
    console.error("Error saving image:", e)
  }
}

function displayImageOnCanvas(e) {
  canvInfo.style.display = "block";
  const t = document.getElementById("canvAttend").getContext("2d");
  if (t) {
    const n = new Image;
    n.src = e, n.onload = () => {
      canvInfo.width = n.width, canvInfo.height = n.height, t.drawImage(n, 0, 0)
    }, n.onerror = () => {
      console.error("Failed to load image:", e)
    }
  } else console.error("Failed to get canvas context.")
}

function customConsoleLog(e) {
  const t = document.getElementById("consoleOutput");
  t && (t.textContent += e + "\n", t.scrollTop = t.scrollHeight), originalConsoleLog(e)
}

async function getPegawaiDataByLabel(e) {
  try {
    const t = await fetch(`/api/getPegawaiData/${encodeURIComponent(e)}`);
    if (!t.ok) throw new Error("Network response was not ok");
    return await t.json()
  } catch (e) {
    return console.error("Error fetching pegawai data:", e), null
  }
}

function displayPegawaiData(e) {
  const t = pegawaiKosong; // Elemen utama untuk data pegawai
  if (t) {
    // Daftar ID elemen dan properti data yang sesuai
    const fields = [
      { id: "lokasi", value: `${e.lokasi || "N/A"}` },
      { id: "kodePegawai", value: `${e.kode_pegawai || "N/A"}` },
      { id: "nikPegawai", value: `${e.nik_pegawai || "N/A"}` },
      { id: "namaPegawai", value: `${e.full_name || "N/A"}` },
      { id: "jabatan", value: `${e.jabatan_relasi ? e.jabatan_relasi.nama_jabatan : "N/A"}` },
      { id: "golongan", value: `${e.golongan_relasi ? e.golongan_relasi.nama_golongan : "N/A"}` },
    ];

    // Perbarui nilai masing-masing elemen menggunakan perulangan
    fields.forEach(field => {
      const element = document.getElementById(field.id);
      if (element) {
        element.textContent = field.value;
      } else {
        console.error(`Element with ID '${field.id}' not found`);
      }
    });
  }
}

function attendanceAlert() {
  Swal.fire({
    title: "Sukses!",
    html: "Berhasil melakukan absensi.",
    timer: 1500,
    icon: "success",
    showConfirmButton: !1
  }), setTimeout((function () {
    // kosongkan value
    canvInfo.style.display = "none";
    const fields = [
      { id: "lokasi", value: `` },
      { id: "kodePegawai", value: `` },
      { id: "nikPegawai", value: `` },
      { id: "namaPegawai", value: `` },
      { id: "jabatan", value: `` },
      { id: "golongan", value: `` },
      { id: "waktu-masuk", value: `` },
    ];

    // perbarui nilai masing-masing elemen menggunakan perulangan
    fields.forEach(field => {
      const element = document.getElementById(field.id);
      if (element) {
        element.textContent = field.value;
      } else {
        console.error(`Element with ID '${field.id}' not found`);
      }
    });

  }), 2e3)
}

async function saveAttendance(employeeCode, employeeNIK) {
  try {
    const attendanceCheckResponse = await fetch("/check-attendance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-TOKEN": csrfToken
      },
      body: JSON.stringify({
        kode_pegawai: employeeCode,
        nik_pegawai: employeeNIK
      })
    }),
      attendanceCheckData = await attendanceCheckResponse.json();

    if (attendanceCheckData.hasClockedIn) {
      const clockInTime = attendanceCheckData.jam_masuk;
      document.getElementById("waktu-masuk").textContent = `${clockInTime}`;
      const clockOutResponse = await fetch("/store-attendance-out", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-TOKEN": csrfToken
        },
        body: JSON.stringify({
          kode_pegawai: employeeCode,
          nik_pegawai: employeeNIK
        })
      }),
        clockOutData = await clockOutResponse.json();
      clockOutData.success
        ? (console.log(clockOutData.message), attendanceAlert())
        : console.error("Failed to record clock-out:", clockOutData.message);
    } else {
      const currentDateTime = new Date(),
        dateTimeFormat = {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: false,
          timeZone: "Asia/Jakarta"
        },
        formattedDateTime = currentDateTime.toLocaleString("id-ID", dateTimeFormat);
      document.getElementById("waktu-masuk").textContent = `${formattedDateTime}`;
      const clockInResponse = await fetch("/store-attendance", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-TOKEN": csrfToken
        },
        body: JSON.stringify({
          kode_pegawai: employeeCode,
          nik_pegawai: employeeNIK,
          jam_masuk: currentDateTime.toISOString()
        })
      }),
        clockInData = await clockInResponse.json();
      clockInData.success
        ? (console.log(clockInData.message), attendanceAlert())
        : console.error("Failed to record clock-in:", clockInData.message);
    }

    // insert to api
    const mainServerResponse = await fetch("api/proxy/server/attendance", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-TOKEN": csrfToken
      },
      body: JSON.stringify({
        kode_jari: employeeCode,
      })
    }),
      mainServerData = await mainServerResponse.json();
    // mainServerData.success
    //   ? (console.log(mainServerData.message), attendanceAlert())
    // : console.error("Failed to connect to API:", mainServerData.message);
    console.log("Server: " + mainServerData.message);
    // insert to api

  } catch (error) {
    console.error("Error checking or saving attendance:", error);
  }
}

console.log = customConsoleLog, canvInfo.style.display = "none", startButton.addEventListener("click", (async () => {
  if (overlay.style.display = "block", canvInfo.style.display = "none", startButton.setAttribute("disabled",
    "disabled"), endButton.removeAttribute("disabled"), !webcamStarted && modelsLoaded) try {
      const e = await navigator.mediaDevices.getUserMedia({
        video: !0,
        audio: !1
      });
      video.srcObject = e, videoStream = e, webcamStarted = !0, console.log("Webcam started successfully"),
        startFaceDetection()
    } catch (e) {
      console.error("Error accessing webcam:", e)
    }
})), video.addEventListener("loadedmetadata", (() => {
  video.width = video.videoWidth, video.height = video.videoHeight, overlay.width = video.width, overlay.height =
    video.height
})), endButton.addEventListener("click", (() => {
  canvInfo.style.display = "none", pegawaiKosong.style.display = "block", pegawaiInfo.style.display = "none",
    overlay.style.display = "none", startButton.removeAttribute("disabled"), endButton.setAttribute("disabled",
      "disabled"), stopWebcam()
}));